#include "stm32f4xx.h "
#include "font.h" 
#include "correct_ANSI.h"

// здесь корректируем на те символы, которые мы оставили между рус. и англ.
// принцип:
// 1.смотрим номер в таблице ANSI
// 2.смотрим, какой по счету в МОЕМ списке следует этот символ начиная от 127-го
// скажем, крест (для примера)  у меня, у МЕНЯ, в моем списке! , идет первый после английских, а  символ градуса седьмым
// причем сдесь сразу вычислена поправка на первые 32 непечатных символа
// Итак, должно получиться 127-32 = 95, впрочем можно просто взять и посчитать:-)
// после этого в case вписуем номер символа по ANSI, а возвращаем наш номер по порядку

char corr_ANSI (unsigned char *s, unsigned char z) 
{

	if 			((s [z]) == 134) return  95; //крест
	else if ((s [z]) == 150) return  96; //-- (широк. дефис)
	else if ((s [z]) == 151) return  97; // ---  (еще шире дефис)
	else if ((s [z]) == 168) return  98; // йо заглавная (Кейл не знает буквы йо:-)
	else if ((s [z]) == 169) return  99; // С компани
	else if ((s [z]) == 174) return 100; // R ("фирма")
	else if ((s [z]) == 176) return 101; // символ градуса
	else if ((s [z]) == 184) return 102; // йо маленькая
	else if ((s [z]) == 186) return 103; // номер, ... тоже не знает такого
		
	return 32 ;
	/*
			switch (m)
			{
				case 134: return  95; break; //крест
				case 150: return  96; break; //-- (широк. дефис)
				case 151: return  97; break; // ---  (еще шире дефис)
				case 168: return  98; break; // йо заглавная (Кейл не знает буквы йо:-)
				case 169: return  99; break; // С компани
				case 174: return 100; break; // R ("фирма")
				case 176: return 101; break; //градус
				case 184: return 102; break; // йо маленькая
				case 185: return 103; break; // номер, ... тоже не знает такого
				
				default: return 32; break;				
			}					
	*/
	}
